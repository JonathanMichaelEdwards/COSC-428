# COSC428 Lab 1 - Working with Cameras

## Objectives
The overall goal of this lab is to introduce **OpenCV code for displaying, recording, and replaying video**.

Given this background, you will then use **tools to change camera attributes and edit video**.

Finally, you will **calibrate a camera to remove radial distortion** (fisheye lens distortion).

## Preparation
Do not install OpenCV on Lab 3 PCs because OpenCV is already installed on these PCs.

Download the "Lab 1 files" zip archive from Learn, or from the [Git repository on eng-git](https://eng-git.canterbury.ac.nz/owb14/cosc428-lab1). The following files should be in that zip file:
- camera_driver.py
- checkerboard.png
- find_camera_calibration.py
- lab01_handout.md
- load_camera_calibration.py
- load_video_file.py
- video_from_webcam.py
- webcam_to_file.py

## Troubleshooting
- If you get a video I/O error, change the “0” in VideoCapture to “-1” which grabs the first available camera.
- If you still cannot access the camera at any time, try unplugging it and plugging it back in.
- You can check your camera exists on Linux with: `ls /dev/video*` in the bash terminal.
- If you get error `QObject::moveToThread: Current thread is not the object's thread. Cannot move to target thread` on a Lab 3 PC, then you probably accidentally installed OpenCV. (To fix, pip3 uninstall opencv-python (or pip uninstall opencv-python))

## Display Video from a Webcam
One of the most basic tasks in OpenCV is to simply start retrieving video data from the camera so that we can start providing our algorithms with some data. At the moment, however, we don’t have any data, so we’ll start withshowing the video to the screen for now.

The integer passed into the cv2.VideoCapture() function specifies the camera used. For a computer with a single camera, using 0 will work. Otherwise, you might need to do some testing to determine which device it is that you wish to use.

### To do:
Run `video_from_webcam.py`

Add the following line of code just before imshow() and observe the effect:
```
frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
```


## Save Video from a Webcam to a File
It is convenient to save video from a webcam to file for use as a consistent test file while tweaking an algorithm. This code stores the video in an .avi file using the XVID codec, but the commands for other containers and codecs can be found in the OpenCV documentation.

### To do:
Run `webcame_to_file.py` and check that an `output.avi` file was created in your local directory.

Play `output.avi` to check that it recorded correctly.


## Load a video from a File
Now that we have stored our video, we need a way of opening it again. As it happens, the method for capturing the video from a webcam is the same for opening a video file. Instead of specifying a number for the camera, we pass in a file name instead. 

In this example, the frame is converted to grayscale before being displayed, but in practice that is where you would perform your algorithm.

### To do:
Run ` load_video_file.py`
Modify the code to skip the `cv2.cvtColor` line and observe the difference.


## Camera Calibration
Perfection is hard, and isn’t typically cheap either. As a result, the lens and image sensor of a webcam differ slightly from device to device. Camera calibration allows one to correct distortions caused by these irregularities. The calibration parameters generated by this process can then be saved and loaded when the camera is used for a computer vision algorithm.

While modern cameras are relatively consistent, and can seem to be free from most distortion effects, even subtle changes can cause problems. For example, if an algorithm uses straight edges to detect a given feature, if there is a radial distortion introduced into the image as a result of a lens imperfection, then the algorithm may not perform correctly.

To calibrate the camera, run the `find_camera_calibration.py` script, and hold a checkerboard image in front of the camera and **ensure that the *entire* checkerboard is visible at all times**. To get a good calibration result, it is important to rotate the checkerboard, and put it at angles to the webcam, while also making sure that a range of poses are recorded all over the webcam’s field of view. (Tip: Lie the checkerboard flat on desk and move webcam.)

Once calibrated, the lines of the checkerboard should be completely straight when viewed through the webcam. If this is not the case, you should run the calibration again, taking care to ensure the checkerboard is flat during calibration.

A 6x9 checkerboard can be downloaded [here](https://docs.opencv.org/2.4/_downloads/pattern.png). Note that it isn't necessary to print the checkerboard. It works just fine if shown on a monitor instead.

### Generating the Calibration Files
Here the camera calibration is performed with the checkerboard pattern. There is a short delay after every frame where the checkerboard is detected to limit the number of frames we need to process later.

The two calibration files “camera_matrix.npy” and “distortion_coeff.npy” are saved for later use.

#### To do:
Run `find_camera_calibration.py` and collect about six images at completely different angles and positions in the image, and **then hold down “q” until “Calculating Camera Distortion...” is displayed.**

(Note: If you have changed brightness, contrast or saturation, change them all back to default or 50%.) 

You can compare your values in your two calibration files “camera_matrix.npy” and “distortion_coeff.npy” with those generated for one of the cameras in the labs:
```
camera_matrix = np.array([[ 1.10203699+03,  0.00000000e+00,  2.97856040+02,
                            0.00000000+00,  1.10715227e+03,  219618658e+02,
                            0.00000000+00,  0.000000000+00,  1.00000000+00,   
]])
distortion_coeff = np.array([7.978574896538845329e+02, 3.400042995004967317e+00, 
                            -1.786514214937548820e-02, -3.217060871280347668e-03,
                            -2.063856972981825777e+01])
```

Note that the point of this exercise is to demonstrate how to correct for camera distortions. It is not necessary to understand the details of every function and variable within `find_camera_calibration.py`.

### Loading the Camera Calibration
This shows how to load the calibration data for a camera and using it to produce an image that has been corrected for defects in the camera.

#### To do:
Run `load_camera_calibration.py`and verify that the lines in the displayed image are straight.
Try replacing the `dst` parameter in `imshow()` with `frame` and look for the distortion difference in straight lines in the resulting images. It can help to look near the edge of the camera with and without the correction.


## Other Tools

### Webcam Driver - Guvcview
This application is useful for directly controlling many parameters for your webcam, as well as allowing you to easily capture images and videos. These files can then be later loaded by OpenCV for testing your algorithms with a consistent data source. 

**Note that any changes you make to these settings will persist until the next time you reboot your computer, since you’re making changes inside the camera, rather than editing images that have already been received.**

**Additionally, there have been reports of irreversible changes to webcam settings on student's own devices. It might be worth avoiding using this application on your own webcam.**

It is included by default in the Ubuntu and Mint repositories, so you can easily install it on your own machines at home using `sudo apt install guvcview`.

Note that if you are running guvcview inside a virtual machine, some of the options may not be available, in which case you will need to use on of the lab machines or on another device running Linux.

Also, guvcview outputs files `.mkv` video files instead of the `.avi` files that you might be used to. `.avi` and `.mkv` are both video container formats, and OpenCV is happy to deal with both, so there’s no need to be worried about this.

#### Updating webcam settings from OpenCV and Python
Changing webcam settings such as brightness, contrast and saturation can be done using Python. An example of this is in camera_driver.py in the lab directory. All you need is a line (placed before the while loop), like
```
cap.set(cv2.CAP_PROP_BRIGHTNESS, brightness)
```
Where the `brightness` variable is a floating-point number between 0 and 1. There are a range of other values that can also be modified. These can be found online if oyu look for them. Alternatively, just using guvcview should also be fine.

#### To do:
Run guvcview above and observe the effects of the various settings.
Add the above `cap.set()` line to the video_from_webcam.py script (after removing your added cv2.cvtColor() line).

Is the change persistent or does brightness revert to the original value every time you restart your program?

### Simple Video Editing - OpenShot
OpenShot is a simple video editing tool that can be used to quickly assemble a video from a series of shorter clips and/or still images. Additional text slides can also be created inside OpenShot from within the “Title” menu on the menu bar.

#### To do:
Follow the instructions below using the video you recorded earlier

- Videos and images are added to the project by dragging them into the “Project Files” window in the top left. From there, clips can be dragged down into the “Timeline” window at the bottom of the screen.
- To preview the video, drag the red arrow in the “Timeline” window to the desired point in the video and select play in the preview window in the top right.
- Once you are satisfied with your video, it can be exported to a range of formats. The export interface can be accessed under the “File” menu, or by pressing “Ctrl+E”. There are some presets available that target a range of web services, devices, etc., but additional control is available under the “Advanced” settings tab in the export window.
- Once your video has been exported, it is possible to upload a video directly to YouTube through the “Upload Video” under the “File” menu.
- OpenShot has a range of other features (including animations and scene transitions) that are documented on the [website](http://www.openshot.org/static/files/user-guide/index.html)

